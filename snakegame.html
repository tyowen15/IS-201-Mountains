<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dragon Snake â€” Chinese Festival</title>
<style>
  :root{
    --bg-deep: #fff7f0;
    --panel:#fff4eb;
    --accent-red:#e11d2d;
    --accent-gold:#f6c84c;
    --accent-dark:#7a0b10;
    --muted:#6b4540;
    --glass: rgba(255,255,255,0.6);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans SC", system-ui;
    background:
      radial-gradient(circle at 10% 20%, rgba(226,29,45,0.06), transparent 10%),
      linear-gradient(180deg, #fff8f2 0%, #fff2ea 100%),
      var(--bg-deep);
    color:var(--accent-dark);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
  }

  .frame{
    width:100%;
    max-width:1060px;
    background: linear-gradient(180deg, rgba(255,255,255,0.7), rgba(255,250,240,0.6));
    border-radius:18px;
    padding:18px;
    box-shadow: 0 12px 50px rgba(122,11,16,0.14);
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:18px;
    border: 3px solid rgba(241,182,61,0.12);
  }

  header{grid-column:1/-1; display:flex; align-items:center; justify-content:space-between; gap:12px}
  h1{margin:0; font-weight:700; color:var(--accent-dark); font-size:20px;}
  .controls-row{display:flex; gap:8px; align-items:center}

  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,245,235,0.4));
    border-radius:12px;
    padding:12px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
  }

  .game-wrap{
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
    justify-content:center;
  }

  canvas{
    background:
      repeating-linear-gradient(45deg, rgba(226,29,45,0.03) 0 10px, rgba(246,200,76,0.02) 10px 20px),
      linear-gradient(180deg, rgba(255,250,240,0.9), rgba(255,245,235,0.7));
    border-radius:12px;
    width:100%;
    max-width:760px;
    height:auto;
    box-shadow: 0 20px 40px rgba(122,11,16,0.12);
    border: 6px solid var(--accent-red);
  }

  .meta{display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap}
  .stat{ background:var(--glass); padding:8px 12px; border-radius:999px; font-size:14px; color:var(--muted); min-width:88px; text-align:center;}
  .stat strong{display:block; color:var(--accent-dark); font-size:18px;}

  .hint{ font-size:13px; color:var(--muted); text-align:center }

  .side{ display:flex; flex-direction:column; gap:12px }
  label{ font-size:13px; color:var(--muted); display:block; margin-bottom:8px }

  .row{display:flex; gap:8px; align-items:center}
  .btn{
    background: linear-gradient(180deg, var(--accent-red), #b10f17);
    color: white;
    border: none;
    padding:10px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:700;
    box-shadow: 0 6px 18px rgba(225,29,45,0.18);
  }
  .btn.secondary{ background: transparent; color:var(--accent-dark); border:1px solid rgba(122,11,16,0.06); box-shadow:none }

  input[type="range"]{ width:100% }

  .dpad{ display:grid; grid-template-areas: ". up ." "left . right" ". down ."; grid-gap:8px; place-items:center; width:170px; margin:0 auto }
  .dpad button{ width:52px; height:52px; border-radius:10px; font-weight:800; font-size:18px; background:var(--accent-gold); border:2px solid #f2d28a; box-shadow: 0 6px 14px rgba(246,200,76,0.25) }

  footer{ grid-column:1/-1; text-align:center; color:var(--muted); font-size:13px; margin-top:6px }

  @media (max-width:980px){
    .frame{ grid-template-columns:1fr; padding:12px }
    canvas{ max-width:100% }
    .side{ order:2 }
  }

  /* decorative corner pattern */
  .corner-deco{
    position:absolute;
    width:80px;
    height:80px;
    pointer-events:none;
    background:
      radial-gradient(circle at 20% 20%, rgba(241,182,61,0.22), transparent 20%),
      repeating-linear-gradient(45deg, rgba(226,29,45,0.06) 0 8px, transparent 8px 16px);
    border-radius:12px;
    transform: rotate(15deg);
    opacity:0.9;
  }
  .corner-deco.right{ right:10px; top:10px }
  .corner-deco.left{ left:10px; bottom:10px }
</style>
</head>
<body>
  <div class="frame" role="application" aria-label="Dragon Snake">
    <header>
      <h1>Dragon Snake â€” Festival Edition</h1>
      <div class="controls-row">
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="restartBtn" class="btn">Restart</button>
      </div>
    </header>

    <main class="game-wrap panel" aria-live="polite">
      <canvas id="game" width="800" height="600" aria-label="Dragon Snake Canvas"></canvas>

      <div class="meta" aria-hidden="false">
        <div class="stat"><span>Score</span><strong id="score">0</strong></div>
        <div class="stat"><span>High</span><strong id="highscore">0</strong></div>
        <div class="stat"><span>Speed</span><strong id="speedDisplay">6</strong></div>
      </div>

      <div class="hint" id="statusText">Arrow keys / WASD to move â€¢ Hitting a wall ends the run â€¢ Golden coins are food</div>
    </main>

    <aside class="side">
      <div class="panel">
        <label for="speedRange">Speed (ticks/sec)</label>
        <input id="speedRange" type="range" min="4" max="18" step="1" value="6" />
        <div style="display:flex; gap:8px; margin-top:10px;">
          <button id="easyBtn" class="btn secondary">Easy</button>
          <button id="normalBtn" class="btn">Normal</button>
          <button id="hardBtn" class="btn secondary">Hard</button>
        </div>
      </div>

      <div class="panel">
        <label>Mobile Controls</label>
        <div class="dpad" role="group" aria-label="directional pad">
          <button data-dir="up" aria-label="up">â–²</button>
          <button data-dir="left" aria-label="left">â—€</button>
          <button data-dir="right" aria-label="right">â–¶</button>
          <button data-dir="down" aria-label="down">â–¼</button>
        </div>
      </div>

      <div class="panel" style="text-align:center; color:var(--muted)">
        Tip: collect coins to grow the dragon. Walls are lethal now â€” avoid crashing!
      </div>
    </aside>

    <footer>Made with festive vibes ðŸŽŠ â€¢ Press Space or P to pause â€¢ R to restart</footer>
    <div class="corner-deco left"></div>
    <div class="corner-deco right"></div>
  </div>

<script>
/* Dragon Snake â€” Single File
   - Chinese festival theme (red & gold)
   - Dragon head + segmented animated body
   - Walls are lethal (no wrap)
   - Golden coin food
   - Local high score persistence
   - Keyboard + touch + responsive
*/

(() => {
  // Canvas + DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha: false});
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('highscore');
  const speedDisplay = document.getElementById('speedDisplay');
  const speedRange = document.getElementById('speedRange');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const statusText = document.getElementById('statusText');
  const dpadButtons = Array.from(document.querySelectorAll('.dpad button'));
  const easyBtn = document.getElementById('easyBtn');
  const normalBtn = document.getElementById('normalBtn');
  const hardBtn = document.getElementById('hardBtn');

  // Logical grid
  const CELL_COUNT_X = 32;
  const CELL_COUNT_Y = 24;

  // Game state
  let cellW, cellH;
  let snake = [];
  let direction = {x:1,y:0};
  let nextDirection = {...direction};
  let food = null;
  let score = 0;
  let highScore = parseInt(localStorage.getItem('dragon_snake_high') || '0', 10) || 0;
  highEl.textContent = highScore;
  let speed = Number(speedRange.value);
  speedDisplay.textContent = speed;
  let tickInterval = 1000 / speed;
  let lastTick = 0;
  let running = true;
  let gameOver = false;
  let timeAccumulator = 0;

  // Visuals palette
  const palette = {
    bg: '#fff7f0',
    red: '#e11d2d',
    gold: '#f6c84c',
    dark: '#7a0b10',
    scaleLight: '#ffd86b',
    scaleDark: '#e3a824',
    coin: '#ffd24d',
    coinEdge: '#b57f13'
  };

  // Initialize sizes, game
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const desiredWidth = Math.max(480, Math.floor(rect.width));
    const desiredHeight = Math.max(360, Math.floor(rect.width * 0.75));
    canvas.width = Math.floor(desiredWidth * dpr);
    canvas.height = Math.floor(desiredHeight * dpr);
    canvas.style.width = desiredWidth + 'px';
    canvas.style.height = desiredHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cellW = (canvas.width / dpr) / CELL_COUNT_X;
    cellH = (canvas.height / dpr) / CELL_COUNT_Y;
  }
  window.addEventListener('resize', () => { resizeCanvas(); draw(); });

  // Helpers
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function placeFood(){
    let tries = 0;
    while(tries < 2000){
      tries++;
      const fx = randInt(0, CELL_COUNT_X-1);
      const fy = randInt(0, CELL_COUNT_Y-1);
      if (!snake.some(s => s.x===fx && s.y===fy)){
        food = {x:fx,y:fy};
        return;
      }
    }
    food = null;
  }

  function resetGame(){
    snake = [];
    // start with 4 segments
    const startX = Math.floor(CELL_COUNT_X/2);
    const startY = Math.floor(CELL_COUNT_Y/2);
    for (let i=0;i<4;i++){
      snake.push({x:startX - i, y:startY});
    }
    direction = {x:1,y:0};
    nextDirection = {...direction};
    score = 0;
    scoreEl.textContent = score;
    gameOver = false;
    running = true;
    statusText.textContent = 'Happy Festival! Collect coins â€” walls are deadly!';
    placeFood();
  }

  // Input handling
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { setDirection(0,-1); e.preventDefault(); }
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { setDirection(0,1); e.preventDefault(); }
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { setDirection(-1,0); e.preventDefault(); }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { setDirection(1,0); e.preventDefault(); }

    if (e.key === ' ' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); }
    if (e.key === 'r' || e.key === 'R') restart();
  });

  dpadButtons.forEach(btn=>{
    btn.addEventListener('pointerdown', (ev)=>{
      const dir = btn.dataset.dir;
      if (dir === 'up') setDirection(0,-1);
      if (dir === 'down') setDirection(0,1);
      if (dir === 'left') setDirection(-1,0);
      if (dir === 'right') setDirection(1,0);
      btn.classList.add('active');
      ev.preventDefault();
    });
    btn.addEventListener('pointerup', ()=>btn.classList.remove('active'));
    btn.addEventListener('pointercancel', ()=>btn.classList.remove('active'));
  });

  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', restart);
  speedRange.addEventListener('input', () => {
    speed = Number(speedRange.value);
    speedDisplay.textContent = speed;
    tickInterval = 1000 / speed;
  });
  easyBtn.addEventListener('click', ()=>{ speedRange.value = 4; speedRange.dispatchEvent(new Event('input')); });
  normalBtn.addEventListener('click', ()=>{ speedRange.value = 8; speedRange.dispatchEvent(new Event('input')); });
  hardBtn.addEventListener('click', ()=>{ speedRange.value = 12; speedRange.dispatchEvent(new Event('input')); });

  function setDirection(dx,dy){
    // prevent reversing directly
    if (dx === -direction.x && dy === -direction.y) return;
    nextDirection = {x:dx,y:dy};
  }

  // Game tick
  function step(){
    // apply nextDirection
    direction = nextDirection;
    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

    // walls are lethal
    if (head.x < 0 || head.x >= CELL_COUNT_X || head.y < 0 || head.y >= CELL_COUNT_Y){
      endGame('You hit the wall! ðŸ§§');
      return;
    }

    // collision with self?
    if (snake.some(seg => seg.x === head.x && seg.y === head.y)){
      endGame('You crashed into yourself!');
      return;
    }

    snake.unshift(head);

    // eat coin?
    if (food && head.x === food.x && head.y === food.y){
      score += 1;
      scoreEl.textContent = score;
      placeFood();
      // gentle speed increase for challenge
      if (score % 4 === 0 && speed < 20){
        speed++;
        speedRange.value = speed;
        speedRange.dispatchEvent(new Event('input'));
      }
    } else {
      snake.pop();
    }
  }

  function endGame(msg){
    gameOver = true;
    running = false;
    statusText.textContent = msg + ' Press Restart or R to play again.';
    pauseBtn.textContent = 'Paused';
    if (score > highScore){
      highScore = score;
      localStorage.setItem('dragon_snake_high', String(highScore));
      highEl.textContent = highScore;
      statusText.textContent += ' New high score! ðŸŽ‰';
    }
  }

  function togglePause(){
    if (gameOver) return;
    running = !running;
    pauseBtn.textContent = running ? 'Pause' : 'Resume';
    statusText.textContent = running ? 'Resumed' : 'Paused';
  }
  function restart(){ resetGame(); pauseBtn.textContent = 'Pause'; }

  // Rendering helpers
  function drawRoundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
  }

  // dragon segment drawing: scales and center highlight
  function drawSegment(x,y,index, t){
    // center pixel position (in canvas pixels)
    const cx = x*cellW + cellW/2;
    const cy = y*cellH + cellH/2;

    // wiggle offset for undulation
    const wiggle = Math.sin((t*0.004) + index*0.6) * (Math.min(cellW,cellH) * 0.12);
    // draw oval-ish segment
    ctx.save();
    ctx.translate(cx, cy + wiggle);

    // segment body gradient
    const segW = cellW * 0.94;
    const segH = cellH * 0.92;
    const grad = ctx.createLinearGradient(-segW/2, -segH/2, segW/2, segH/2);
    grad.addColorStop(0, palette.scaleLight);
    grad.addColorStop(1, palette.scaleDark);
    ctx.fillStyle = grad;
    drawRoundedRect(-segW/2, -segH/2, segW, segH, Math.min(segW,segH)*0.28);

    // draw little "scale" arcs across the top
    const scales = 5;
    ctx.fillStyle = palette.scaleDark;
    for (let s=0;s<scales;s++){
      const px = -segW/2 + (s+0.5)*(segW/scales);
      const py = -segH/2 + segH*0.18 + (Math.sin((t*0.01) + index*0.2 + s)*2);
      ctx.beginPath();
      ctx.ellipse(px, py, segW*0.14, segH*0.12, 0, Math.PI, 0);
      ctx.fill();
    }

    // center highlight
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-segW*0.12, -segH*0.28, segW*0.18, segH*0.12, -0.4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  // draw the dragon head (festive)
  function drawHead(x,y, t, dir){
    const cx = x*cellW + cellW/2;
    const cy = y*cellH + cellH/2;
    ctx.save();
    ctx.translate(cx, cy);

    // rotate to face direction
    let angle = 0;
    if (dir.x === 1) angle = 0;
    if (dir.x === -1) angle = Math.PI;
    if (dir.y === 1) angle = Math.PI/2;
    if (dir.y === -1) angle = -Math.PI/2;
    ctx.rotate(angle);

    const w = cellW * 1.18;
    const h = cellH * 1.18;

    // head body
    ctx.beginPath();
    ctx.ellipse(0, 0, w*0.6, h*0.6, 0, 0, Math.PI*2);
    ctx.fillStyle = palette.red;
    ctx.fill();

    // muzzle
    ctx.beginPath();
    ctx.ellipse(w*0.33, 0, w*0.25, h*0.2, 0, 0, Math.PI*2);
    ctx.fillStyle = palette.gold;
    ctx.fill();

    // eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.ellipse(-w*0.05, -h*0.15, w*0.12, h*0.12, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-w*0.05, h*0.15, w*0.12, h*0.12, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#3a0606';
    ctx.beginPath(); ctx.ellipse(-w*0.05, -h*0.15, w*0.05, h*0.05, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-w*0.05, h*0.15, w*0.05, h*0.05, 0, 0, Math.PI*2); ctx.fill();

    // horns
    ctx.fillStyle = palette.gold;
    ctx.beginPath(); ctx.moveTo(-w*0.18, -h*0.6); ctx.lineTo(-w*0.5, -h*1.0); ctx.lineTo(-w*0.05, -h*0.45); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(-w*0.18, h*0.6); ctx.lineTo(-w*0.5, h*1.0); ctx.lineTo(-w*0.05, h*0.45); ctx.closePath(); ctx.fill();

    // whiskers (animated)
    const whiskerLen = w*0.9;
    ctx.strokeStyle = palette.gold;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(w*0.28, -h*0.06);
    ctx.quadraticCurveTo(w*0.28+whiskerLen*0.2, -h*0.25, w*0.28+whiskerLen, -h*0.12 - Math.sin(t*0.01)*4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w*0.28, h*0.06);
    ctx.quadraticCurveTo(w*0.28+whiskerLen*0.2, h*0.25, w*0.28+whiskerLen, h*0.12 + Math.cos(t*0.01)*4);
    ctx.stroke();

    // nostril/shimmer
    ctx.fillStyle = palette.dark;
    ctx.beginPath(); ctx.ellipse(w*0.33, -h*0.06, w*0.04, h*0.03, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(w*0.33, h*0.06, w*0.04, h*0.03, 0, 0, Math.PI*2); ctx.fill();

    // mouth accent
    ctx.strokeStyle = palette.dark;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-w*0.1, h*0.25); ctx.quadraticCurveTo(w*0.06, h*0.5, w*0.34, h*0.18); ctx.stroke();

    ctx.restore();
  }

  // coin drawing
  function drawCoin(cell){
    const x = cell.x * cellW + cellW/2;
    const y = cell.y * cellH + cellH/2;
    const r = Math.min(cellW,cellH) * 0.32;
    // shadow
    ctx.beginPath(); ctx.ellipse(x, y + r*0.35, r*0.95, r*0.45, 0, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.06)'; ctx.fill();
    // coin circle
    const grad = ctx.createLinearGradient(x-r, y-r, x+r, y+r);
    grad.addColorStop(0, palette.coin);
    grad.addColorStop(1, palette.coinEdge);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    // inner wreath / hole (small emblem)
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.beginPath(); ctx.arc(x, y, r*0.36, 0, Math.PI*2); ctx.fill();
    // small shine
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath(); ctx.ellipse(x - r*0.28, y - r*0.28, r*0.16, r*0.08, -0.4, 0, Math.PI*2); ctx.fill();
    // Chinese coin accent (square hole)
    ctx.fillStyle = palette.coinEdge;
    const sq = r*0.22;
    ctx.fillRect(x - sq/2, y - sq/2, sq, sq);
  }

  // draw walls grid and border
  function drawWalls(){
    ctx.save();
    ctx.strokeStyle = palette.dark;
    ctx.lineWidth = 4;
    // border rectangle (slightly inset)
    const inset = 4;
    ctx.strokeRect(inset, inset, canvas.width / (window.devicePixelRatio || 1) - inset*2, canvas.height / (window.devicePixelRatio || 1) - inset*2);
    ctx.restore();
  }

  // main draw
  function draw(t = 0){
    // clear background
    ctx.fillStyle = palette.bg;
    ctx.fillRect(0,0,canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));

    // draw grid subtle
    ctx.save();
    ctx.globalAlpha = 0.04;
    for (let gx=0; gx<=CELL_COUNT_X; gx++){
      const px = Math.round(gx*cellW) + 0.5;
      ctx.fillRect(px, 0, 1, canvas.height / (window.devicePixelRatio || 1));
    }
    for (let gy=0; gy<=CELL_COUNT_Y; gy++){
      const py = Math.round(gy*cellH) + 0.5;
      ctx.fillRect(0, py, canvas.width / (window.devicePixelRatio || 1), 1);
    }
    ctx.restore();

    // walls border
    drawWalls();

    // draw food (coin) under dragon
    if (food) drawCoin(food);

    // draw body segments from tail to head for overlap
    for (let i = snake.length - 1; i >= 1; i--){
      drawSegment(snake[i].x, snake[i].y, i, t);
    }

    // draw head last (on top)
    if (snake.length > 0){
      drawHead(snake[0].x, snake[0].y, t, direction);
    }

    // paused overlay
    if (!running && !gameOver){
      ctx.fillStyle = 'rgba(122,11,16,0.12)';
      ctx.fillRect(0,0,canvas.width/(window.devicePixelRatio || 1), canvas.height/(window.devicePixelRatio || 1));
      ctx.fillStyle = palette.gold;
      ctx.font = `${Math.max(16, cellW)}px system-ui,Segoe UI,Roboto`;
      ctx.textAlign = 'center';
      ctx.fillText('Paused', canvas.width/(2*(window.devicePixelRatio || 1)), canvas.height/(2*(window.devicePixelRatio || 1)));
    }

    // game over overlay
    if (gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.fillRect(0,0,canvas.width/(window.devicePixelRatio || 1), canvas.height/(window.devicePixelRatio || 1));
      ctx.fillStyle = palette.gold;
      ctx.font = `${Math.max(18, cellW*1.2)}px system-ui,Segoe UI,Roboto`;
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/(2*(window.devicePixelRatio || 1)), canvas.height/(2*(window.devicePixelRatio || 1)) - 10);
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(12, cellW*0.9)}px system-ui,Segoe UI,Roboto`;
      ctx.fillText('Press Restart or R to play again', canvas.width/(2*(window.devicePixelRatio || 1)), canvas.height/(2*(window.devicePixelRatio || 1)) + 18);
    }
  }

  // main loop
  function loop(ts){
    if (!lastTick) lastTick = ts;
    const elapsed = ts - lastTick;

    // fixed-tick updates
    if (running && !gameOver && elapsed >= tickInterval){
      lastTick = ts - (elapsed % tickInterval);
      step();
    }

    // always draw smoothly with time for animations
    draw(ts || 0);
    requestAnimationFrame(loop);
  }

  // init
  resizeCanvas();
  resetGame();
  requestAnimationFrame(loop);
  placeFood();

  // Expose for debugging (optional)
  window.__dragonSnake = {
    restart, togglePause, get state(){ return {snake, direction, score, highScore, food, running, gameOver, speed}; }
  };

})();
</script>
</body>
</html>
